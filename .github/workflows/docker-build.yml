# =============================================================================
# iSpy Agent DVR Docker Image Builder
# =============================================================================
# Consolidated workflow for automated and manual Docker image builds
#
# Features:
#   - Automatic release detection (every 30 minutes - time-based)
#   - Multi-platform builds (amd64, arm64, arm/v7)
#   - Dual registry support (Docker Hub + ghcr.io)
#   - Registry synchronization
#   - Manual version builds (range or comma-separated)
#   - Image promotion (latest/stable tags)
#   - 5-day stable promotion
#   - ZSTD compression + OCI media types
#   - Vulnerability scanning (non-blocking)
#   - Build provenance and SBOM
#   - Version validation with warnings (missing versions don't fail build)
#
# Required Secrets:
#   - DOCKERHUB_USERNAME: Docker Hub username
#   - DOCKERHUB_TOKEN: Docker Hub access token (with push permissions)
#
# Note: GITHUB_TOKEN is automatically provided and has packages:write scope
#
# =============================================================================

name: Docker Build & Publish

on:
  # =========================================================================
  # TIME-BASED TRIGGER: Check for new releases every 30 minutes
  # =========================================================================
  schedule:
    - cron: '*/30 * * * *'

  # =========================================================================
  # EXTERNAL TRIGGER: For reliable scheduling via cron-job.org or similar
  # =========================================================================
  repository_dispatch:
    types: [Docker Build & Publish - Cron Scheduled]

  # =========================================================================
  # MANUAL TRIGGER: With detailed input options
  # =========================================================================
  workflow_dispatch:
    inputs:
      # --- Action Selection ---
      action:
        description: 'Select the action to perform'
        required: true
        type: choice
        options:
          - 'auto-check'
          - 'build-versions'
          - 'promote-image'
          - 'sync-registries'
          - 'mark-stable'
        default: 'auto-check'

      # --- Version Build Options ---
      versions:
        description: |
          Versions to build (for build-versions action)
          Examples:
            - Single: 7.0.9.0
            - Multiple: 7.0.5.0,7.0.6.0,7.0.7.0
            - Range: 7.0.5.0-7.0.9.0
        required: false
        type: string
        default: ''

      # --- Base Image Selection ---
      base_image:
        description: 'Base image for Docker build'
        required: false
        type: choice
        options:
          - 'default (latest)'
          - 'trixie-slim-default-ffmpeg'
          - 'bookworm-slim-vlc-jellyfin-ffmpeg'
          - 'custom'
        default: 'default (latest)'

      custom_base_image:
        description: 'Custom base image URL (only when base_image=custom)'
        required: false
        type: string
        default: ''

      # --- Image Promotion Options ---
      promote_version:
        description: 'Source version to promote (for promote-image action)'
        required: false
        type: string
        default: ''

      promote_tag:
        description: 'Target tag for promotion'
        required: false
        type: choice
        options:
          - 'latest'
          - 'stable'
        default: 'latest'

      # --- Build Behavior Options (Checkboxes) ---
      force_build:
        description: 'Force rebuild even if image already exists in registries'
        required: false
        type: boolean
        default: false

      skip_existing:
        description: 'Skip versions that already exist in registries'
        required: false
        type: boolean
        default: true

      tag_as_latest:
        description: 'Also tag the built image(s) as latest'
        required: false
        type: boolean
        default: true

      run_security_scan:
        description: 'Run Trivy security vulnerability scan'
        required: false
        type: boolean
        default: true

      push_to_dockerhub:
        description: 'Push to Docker Hub registry'
        required: false
        type: boolean
        default: true

      push_to_ghcr:
        description: 'Push to GitHub Container Registry (ghcr.io)'
        required: false
        type: boolean
        default: true

      # --- Base Image Update Options ---
      update_base_image:
        description: 'Rebuild if base image has updates (checks digest)'
        required: false
        type: boolean
        default: false

      # --- Platform Options ---
      platforms:
        description: 'Target platforms for multi-arch build'
        required: false
        type: choice
        options:
          - 'linux/amd64,linux/arm64,linux/arm/v7'
          - 'linux/amd64,linux/arm64'
          - 'linux/amd64'
        default: 'linux/amd64,linux/arm64,linux/arm/v7'

      # --- Compression Options ---
      compression_level:
        description: 'ZSTD compression level (1-22, higher = smaller but slower)'
        required: false
        type: choice
        options:
          - '22'
          - '19'
          - '15'
          - '10'
          - '5'
          - '3'
        default: '22'

# Cancel in-progress runs for the same trigger type
# - For scheduled/repository_dispatch: Only one auto-check runs at a time
# - For workflow_dispatch: Groups by the versions input to allow different version builds
concurrency:
  group: docker-build-${{ github.event_name == 'workflow_dispatch' && github.event.inputs.versions || 'auto-check' }}
  cancel-in-progress: false

env:
  # Configuration sourced from repository variables (Settings â†’ Secrets and variables â†’ Actions â†’ Variables)
  # Fallback values used if variables are not set
  TZ: ${{ vars.TZ || 'Asia/Dhaka' }}
  DOCKERHUB_REPO: ${{ vars.DOCKERHUB_REPO || 'mekayelanik/ispyagentdvr' }}
  GHCR_REPO: ${{ vars.GHCR_REPO || 'ghcr.io/mekayelanik/ispyagentdvr' }}
  DEFAULT_PLATFORMS: ${{ vars.DEFAULT_PLATFORMS || 'linux/amd64,linux/arm64,linux/arm/v7' }}
  BINARY_BASE_URL: ${{ vars.BINARY_BASE_URL || 'https://files.ispyconnect.com/downloads' }}
  RELEASE_URL: ${{ vars.RELEASE_URL || 'https://www.ispyconnect.com/producthistory.aspx?productid=27' }}
  DEFAULT_BASE_IMAGE: ${{ vars.DEFAULT_BASE_IMAGE || 'mekayelanik/ispyagentdvr-base-image:ispyagentdvr-trixie-slim-jellyfin-ffmpeg-7.1.3-1' }}
  # Base image update check: set to 'true' to enable automatic rebuilds when base image changes
  UPDATE_BASE_IMAGE_ENABLED: ${{ vars.UPDATE_BASE_IMAGE_ENABLED || 'false' }}

jobs:
  # ===========================================================================
  # Job 1: Check for new releases and validate requested versions
  # ===========================================================================
  check-releases:
    name: Check Releases & Validate Versions
    runs-on: ubuntu-latest
    outputs:
      versions_to_build: ${{ steps.determine-versions.outputs.versions }}
      versions_json: ${{ steps.determine-versions.outputs.versions_json }}
      latest_version: ${{ steps.fetch-releases.outputs.latest_version }}
      latest_is_beta: ${{ steps.fetch-releases.outputs.latest_is_beta }}
      beta_versions: ${{ steps.fetch-releases.outputs.beta_versions }}
      available_versions: ${{ steps.fetch-releases.outputs.available_versions }}
      should_build: ${{ steps.determine-versions.outputs.should_build }}
      should_mark_stable: ${{ steps.check-stable.outputs.should_mark_stable }}
      stable_version: ${{ steps.check-stable.outputs.stable_version }}
      action_type: ${{ steps.set-action.outputs.action }}
      missing_versions: ${{ steps.validate-versions.outputs.missing_versions }}
      base_image_selection: ${{ steps.resolve-base-image.outputs.selection }}
      custom_base_image: ${{ steps.resolve-base-image.outputs.custom }}
      base_image_updated: ${{ steps.check-base-image.outputs.updated }}
      platforms: ${{ steps.set-platforms.outputs.platforms }}
      compression_level: ${{ steps.set-compression.outputs.level }}
      build_matrix: ${{ steps.generate-matrix.outputs.matrix }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Set action type
        id: set-action
        run: |
          if [ "${{ github.event_name }}" == "schedule" ] || [ "${{ github.event_name }}" == "repository_dispatch" ]; then
            echo "action=auto-check" >> $GITHUB_OUTPUT
            echo "Running scheduled auto-check (trigger: ${{ github.event_name }})..."
          else
            echo "action=${{ github.event.inputs.action }}" >> $GITHUB_OUTPUT
            echo "Running manual action: ${{ github.event.inputs.action }}"
          fi

      - name: Set platforms
        id: set-platforms
        run: |
          if [ -n "${{ github.event.inputs.platforms }}" ]; then
            echo "platforms=${{ github.event.inputs.platforms }}" >> $GITHUB_OUTPUT
          else
            echo "platforms=${{ env.DEFAULT_PLATFORMS }}" >> $GITHUB_OUTPUT
          fi

      - name: Set compression level
        id: set-compression
        run: |
          # Default to level 22 (maximum compression) if not specified
          if [ -n "${{ github.event.inputs.compression_level }}" ]; then
            echo "level=${{ github.event.inputs.compression_level }}" >> $GITHUB_OUTPUT
          else
            echo "level=22" >> $GITHUB_OUTPUT
          fi
          echo "ZSTD compression level: ${{ github.event.inputs.compression_level || '22' }}"

      - name: Resolve base image selection
        id: resolve-base-image
        run: |
          INPUT_BASE="${{ github.event.inputs.base_image }}"
          CUSTOM_BASE="${{ github.event.inputs.custom_base_image }}"

          # Output the selection key (not the resolved URL to avoid secret masking)
          # The actual URL will be resolved in each build job
          if [ -z "$INPUT_BASE" ] || [ "$INPUT_BASE" == "default (latest)" ]; then
            echo "selection=default" >> $GITHUB_OUTPUT
          else
            echo "selection=$INPUT_BASE" >> $GITHUB_OUTPUT
          fi

          # Pass custom base image if specified
          if [ "$INPUT_BASE" == "custom" ] && [ -n "$CUSTOM_BASE" ]; then
            echo "custom=$CUSTOM_BASE" >> $GITHUB_OUTPUT
          else
            echo "custom=" >> $GITHUB_OUTPUT
          fi

          echo "Base image selection: ${INPUT_BASE:-default}"

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y curl jq skopeo

      - name: Login to registries
        uses: ./.github/actions/registry-login
        with:
          dockerhub_username: ${{ secrets.DOCKERHUB_USERNAME }}
          dockerhub_token: ${{ secrets.DOCKERHUB_TOKEN }}
          ghcr_actor: ${{ github.actor }}
          ghcr_token: ${{ secrets.GITHUB_TOKEN }}

      - name: Fetch and parse release history
        id: fetch-releases
        run: |
          echo "Fetching release history from iSpy..."

          # Fetch the page
          curl -s "${{ env.RELEASE_URL }}" -o /tmp/releases.html

          # Parse the HTML table to extract versions and dates
          # Note: HTML uses <td valign="top"> so we match full td tag and strip with sed
          grep -oP '<td[^>]*>\d+\.\d+\.\d+\.\d+</td>' /tmp/releases.html | sed 's/<[^>]*>//g' | head -20 > /tmp/versions.txt
          grep -oP '<td[^>]*>\d{1,2}/\d{1,2}/\d{4}</td>' /tmp/releases.html | sed 's/<[^>]*>//g' | head -20 > /tmp/dates.txt

          # Parse beta status: HTML spans multiple lines, so convert to single-line first
          # Then extract each row and check if update info contains (Beta):
          tr '\n' ' ' < /tmp/releases.html | sed 's/  */ /g' > /tmp/releases_oneline.html

          > /tmp/beta_status.txt
          while IFS= read -r version; do
            # Extract the row for this version and check for (Beta): in the update info
            ROW=$(grep -oP "<tr><td[^>]*>${version}</td><td[^>]*>.*?</td><td[^>]*>\d{1,2}/\d{1,2}/\d{4}</td></tr>" /tmp/releases_oneline.html | head -1)
            if echo "$ROW" | grep -q '(Beta):'; then
              echo "$version|true" >> /tmp/beta_status.txt
            else
              echo "$version|false" >> /tmp/beta_status.txt
            fi
          done < /tmp/versions.txt

          # Create combined output (version|date|is_beta)
          paste -d'|' /tmp/versions.txt /tmp/dates.txt > /tmp/releases_temp.txt
          paste -d'|' /tmp/releases_temp.txt <(cut -d'|' -f2 /tmp/beta_status.txt) > /tmp/releases.txt

          # Get latest version and its beta status
          LATEST_VERSION=$(head -1 /tmp/versions.txt)
          LATEST_IS_BETA=$(head -1 /tmp/beta_status.txt | cut -d'|' -f2)
          echo "latest_version=$LATEST_VERSION" >> $GITHUB_OUTPUT
          echo "latest_is_beta=$LATEST_IS_BETA" >> $GITHUB_OUTPUT

          # Create JSON object mapping version -> beta status
          BETA_VERSIONS=$(awk -F'|' '{printf "\"%s\":%s,", $1, $2}' /tmp/beta_status.txt | sed 's/,$//' | sed 's/^/{/' | sed 's/$/}/')
          echo "beta_versions=$BETA_VERSIONS" >> $GITHUB_OUTPUT

          # Create JSON array of available versions
          AVAILABLE_VERSIONS=$(cat /tmp/versions.txt | jq -R -s -c 'split("\n") | map(select(length > 0))')
          echo "available_versions=$AVAILABLE_VERSIONS" >> $GITHUB_OUTPUT

          echo "Latest version: $LATEST_VERSION (beta: $LATEST_IS_BETA)"
          echo "Found $(wc -l < /tmp/versions.txt) versions in release history"
          echo "Beta versions:"
          grep '|true$' /tmp/beta_status.txt | cut -d'|' -f1 || echo "  (none in top 20)"

          # Save for other steps
          cp /tmp/versions.txt /tmp/available_versions.txt
          cp /tmp/beta_status.txt /tmp/beta_status_available.txt

      - name: Validate requested versions against available versions
        id: validate-versions
        run: |
          INPUT_VERSIONS="${{ github.event.inputs.versions }}"
          AVAILABLE_FILE="/tmp/available_versions.txt"

          # Function to check if version exists
          version_exists() {
            grep -q "^$1$" "$AVAILABLE_FILE"
          }

          # Function to expand version range (bidirectional - handles both orderings)
          expand_range() {
            local start=$1
            local end=$2
            local found_versions=""
            local in_range=false
            local start_line=0
            local end_line=0
            local line_num=0

            # First pass: find line numbers of start and end versions
            while IFS= read -r version; do
              line_num=$((line_num + 1))
              if [ "$version" == "$start" ]; then
                start_line=$line_num
              fi
              if [ "$version" == "$end" ]; then
                end_line=$line_num
              fi
            done < "$AVAILABLE_FILE"

            # Determine direction: if start_line > end_line, versions are newest-first
            # Swap if needed so we always iterate from first_line to last_line
            local first_line=$start_line
            local last_line=$end_line
            if [ $start_line -gt $end_line ] && [ $end_line -gt 0 ]; then
              first_line=$end_line
              last_line=$start_line
            fi

            # Second pass: collect versions in range
            line_num=0
            while IFS= read -r version; do
              line_num=$((line_num + 1))
              if [ $line_num -ge $first_line ] && [ $line_num -le $last_line ]; then
                if [ -z "$found_versions" ]; then
                  found_versions="$version"
                else
                  found_versions="$found_versions,$version"
                fi
              fi
            done < "$AVAILABLE_FILE"

            echo "$found_versions"
          }

          MISSING_VERSIONS=""
          VALID_VERSIONS=""

          if [ -n "$INPUT_VERSIONS" ]; then
            # Check if it's a range format (contains - but not at start, and no comma)
            if [[ "$INPUT_VERSIONS" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+-[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              # Range format: 7.0.5.0-7.0.9.0
              START_VER=$(echo "$INPUT_VERSIONS" | cut -d'-' -f1)
              END_VER=$(echo "$INPUT_VERSIONS" | cut -d'-' -f2)

              echo "Processing version range: $START_VER to $END_VER"

              # Check if start and end versions exist
              if ! version_exists "$START_VER"; then
                echo "::warning::Start version $START_VER not found in release history"
                MISSING_VERSIONS="$START_VER"
              fi
              if ! version_exists "$END_VER"; then
                echo "::warning::End version $END_VER not found in release history"
                if [ -z "$MISSING_VERSIONS" ]; then
                  MISSING_VERSIONS="$END_VER"
                else
                  MISSING_VERSIONS="$MISSING_VERSIONS,$END_VER"
                fi
              fi

              # Expand range to get all versions
              VALID_VERSIONS=$(expand_range "$START_VER" "$END_VER")

              if [ -z "$VALID_VERSIONS" ]; then
                echo "::warning::No versions found in range $START_VER to $END_VER"
              fi

            else
              # Comma-separated or single version
              IFS=',' read -ra VERSION_ARRAY <<< "$INPUT_VERSIONS"

              for version in "${VERSION_ARRAY[@]}"; do
                version=$(echo "$version" | xargs)  # Trim whitespace
                if version_exists "$version"; then
                  if [ -z "$VALID_VERSIONS" ]; then
                    VALID_VERSIONS="$version"
                  else
                    VALID_VERSIONS="$VALID_VERSIONS,$version"
                  fi
                else
                  echo "::warning::Version $version not found in release history - will be skipped"
                  if [ -z "$MISSING_VERSIONS" ]; then
                    MISSING_VERSIONS="$version"
                  else
                    MISSING_VERSIONS="$MISSING_VERSIONS,$version"
                  fi
                fi
              done
            fi
          fi

          echo "valid_versions=$VALID_VERSIONS" >> $GITHUB_OUTPUT
          echo "missing_versions=$MISSING_VERSIONS" >> $GITHUB_OUTPUT

          if [ -n "$MISSING_VERSIONS" ]; then
            echo "::warning::The following versions were not found and will be skipped: $MISSING_VERSIONS"
          fi

          echo "Valid versions to process: $VALID_VERSIONS"

      - name: Check existing images in registries
        id: check-existing
        run: |
          check_image_exists() {
            local registry=$1
            local tag=$2
            if skopeo inspect "docker://${registry}:${tag}" > /dev/null 2>&1; then
              echo "exists"
            else
              echo "missing"
            fi
          }

          LATEST_VERSION="${{ steps.fetch-releases.outputs.latest_version }}"
          LATEST_IS_BETA="${{ steps.fetch-releases.outputs.latest_is_beta }}"

          # Determine the actual tag to check (beta has -beta suffix)
          if [ "$LATEST_IS_BETA" == "true" ]; then
            CHECK_TAG="${LATEST_VERSION}-beta"
          else
            CHECK_TAG="${LATEST_VERSION}"
          fi

          echo "Checking for tag: $CHECK_TAG (beta: $LATEST_IS_BETA)"

          # Check Docker Hub
          DOCKERHUB_STATUS=$(check_image_exists "${{ env.DOCKERHUB_REPO }}" "$CHECK_TAG")
          echo "dockerhub_latest_status=$DOCKERHUB_STATUS" >> $GITHUB_OUTPUT

          # Check GHCR
          GHCR_STATUS=$(check_image_exists "${{ env.GHCR_REPO }}" "$CHECK_TAG")
          echo "ghcr_latest_status=$GHCR_STATUS" >> $GITHUB_OUTPUT

          echo "Latest version ($LATEST_VERSION, tag: $CHECK_TAG) - Docker Hub: $DOCKERHUB_STATUS, GHCR: $GHCR_STATUS"

      - name: Check base image for updates
        id: check-base-image
        env:
          DEFAULT_IMAGE: ${{ env.DEFAULT_BASE_IMAGE }}
        run: |
          # Resolve base image from selection (same logic as build-platform job)
          BASE_SELECTION="${{ steps.resolve-base-image.outputs.selection }}"
          CUSTOM_BASE="${{ steps.resolve-base-image.outputs.custom }}"

          case "$BASE_SELECTION" in
            "custom")
              BASE_IMAGE="${CUSTOM_BASE:-$DEFAULT_IMAGE}"
              ;;
            "trixie-slim-default-ffmpeg")
              BASE_IMAGE="mekayelanik/ispyagentdvr-base-image:ispyagentdvr-trixie-slim-default-ffmpeg"
              ;;
            "bookworm-slim-vlc-jellyfin-ffmpeg")
              BASE_IMAGE="mekayelanik/ispyagentdvr-base-image:ispyagentdvr-bookworm-slim-vlc-jellyfin-ffmpeg"
              ;;
            *)
              BASE_IMAGE="$DEFAULT_IMAGE"
              ;;
          esac

          LATEST_VERSION="${{ steps.fetch-releases.outputs.latest_version }}"
          UPDATE_ENABLED="${{ github.event.inputs.update_base_image || env.UPDATE_BASE_IMAGE_ENABLED }}"

          echo "Base image update check enabled: $UPDATE_ENABLED"

          if [ "$UPDATE_ENABLED" != "true" ]; then
            echo "updated=false" >> $GITHUB_OUTPUT
            echo "Base image update check is disabled"
            exit 0
          fi

          echo "Checking if base image has updates..."

          # Get base image digest
          BASE_DIGEST=$(skopeo inspect "docker://${BASE_IMAGE}" 2>/dev/null | jq -r '.Digest' || echo "unknown")
          echo "Base image digest: $BASE_DIGEST"

          if [ "$BASE_DIGEST" == "unknown" ] || [ -z "$BASE_DIGEST" ]; then
            echo "::warning::Could not fetch base image digest"
            echo "updated=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Check if our latest image exists and get its base layer info
          # We store base image digest in labels during build
          CURRENT_IMAGE="${{ env.DOCKERHUB_REPO }}:${LATEST_VERSION}"
          CURRENT_BASE_LABEL=$(skopeo inspect "docker://${CURRENT_IMAGE}" 2>/dev/null | jq -r '.Labels["org.opencontainers.image.base.digest"] // empty' || echo "")

          if [ -z "$CURRENT_BASE_LABEL" ]; then
            # Fallback: check image creation time vs base image creation time
            CURRENT_CREATED=$(skopeo inspect "docker://${CURRENT_IMAGE}" 2>/dev/null | jq -r '.Created' || echo "")
            BASE_CREATED=$(skopeo inspect "docker://${BASE_IMAGE}" 2>/dev/null | jq -r '.Created' || echo "")

            if [ -n "$CURRENT_CREATED" ] && [ -n "$BASE_CREATED" ]; then
              CURRENT_EPOCH=$(date -d "$CURRENT_CREATED" +%s 2>/dev/null || echo "0")
              BASE_EPOCH=$(date -d "$BASE_CREATED" +%s 2>/dev/null || echo "0")

              if [ "$BASE_EPOCH" -gt "$CURRENT_EPOCH" ]; then
                echo "updated=true" >> $GITHUB_OUTPUT
                echo "Base image is newer than current build - rebuild recommended"
                exit 0
              fi
            fi
            echo "updated=false" >> $GITHUB_OUTPUT
            echo "No base image update detected (no label, using timestamp comparison)"
          else
            if [ "$CURRENT_BASE_LABEL" != "$BASE_DIGEST" ]; then
              echo "updated=true" >> $GITHUB_OUTPUT
              echo "Base image digest changed: $CURRENT_BASE_LABEL -> $BASE_DIGEST"
            else
              echo "updated=false" >> $GITHUB_OUTPUT
              echo "Base image unchanged"
            fi
          fi

      - name: Check for 5-day stable promotion
        id: check-stable
        run: |
          # Read latest release info (version|date|is_beta)
          LATEST_LINE=$(head -1 /tmp/releases.txt)
          LATEST_VERSION=$(echo "$LATEST_LINE" | cut -d'|' -f1)
          LATEST_DATE=$(echo "$LATEST_LINE" | cut -d'|' -f2)
          LATEST_IS_BETA=$(echo "$LATEST_LINE" | cut -d'|' -f3)

          if [ -z "$LATEST_DATE" ]; then
            echo "::warning::Could not parse release date"
            echo "should_mark_stable=false" >> $GITHUB_OUTPUT
            echo "stable_version=" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Beta versions cannot be marked as stable
          if [ "$LATEST_IS_BETA" == "true" ]; then
            echo "Latest version $LATEST_VERSION is a BETA release - not eligible for stable"
            echo "should_mark_stable=false" >> $GITHUB_OUTPUT
            echo "stable_version=" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Convert date (M/D/YYYY) to epoch
          # Handle both 1/1/2025 and 12/27/2025 formats
          MONTH=$(echo "$LATEST_DATE" | cut -d'/' -f1)
          DAY=$(echo "$LATEST_DATE" | cut -d'/' -f2)
          YEAR=$(echo "$LATEST_DATE" | cut -d'/' -f3)

          LATEST_EPOCH=$(date -d "$YEAR-$MONTH-$DAY" +%s 2>/dev/null || echo "0")
          CURRENT_EPOCH=$(date +%s)
          FIVE_DAYS_SECONDS=$((5 * 24 * 60 * 60))
          DAYS_OLD=$(( (CURRENT_EPOCH - LATEST_EPOCH) / 86400 ))

          echo "Latest release ($LATEST_VERSION) is $DAYS_OLD days old"

          if [ $LATEST_EPOCH -gt 0 ] && [ $((CURRENT_EPOCH - LATEST_EPOCH)) -ge $FIVE_DAYS_SECONDS ]; then
            echo "should_mark_stable=true" >> $GITHUB_OUTPUT
            echo "stable_version=$LATEST_VERSION" >> $GITHUB_OUTPUT
            echo "Version $LATEST_VERSION is $DAYS_OLD days old, eligible for stable"
          else
            echo "should_mark_stable=false" >> $GITHUB_OUTPUT
            echo "stable_version=" >> $GITHUB_OUTPUT
            echo "Version is less than 5 days old, not eligible for stable yet"
          fi

      - name: Determine versions to build
        id: determine-versions
        run: |
          ACTION="${{ steps.set-action.outputs.action }}"
          FORCE_BUILD="${{ github.event.inputs.force_build }}"
          SKIP_EXISTING="${{ github.event.inputs.skip_existing }}"
          LATEST_VERSION="${{ steps.fetch-releases.outputs.latest_version }}"
          BETA_VERSIONS='${{ steps.fetch-releases.outputs.beta_versions }}'

          filter_existing_versions() {
            local versions=$1
            local filtered=""

            IFS=',' read -ra VERSION_ARRAY <<< "$versions"
            for version in "${VERSION_ARRAY[@]}"; do
              version=$(echo "$version" | xargs)

              if [ "$SKIP_EXISTING" == "true" ] && [ "$FORCE_BUILD" != "true" ]; then
                # Check if this version is beta to determine the actual tag
                IS_BETA=$(echo "$BETA_VERSIONS" | jq -r --arg v "$version" '.[$v] // false')
                if [ "$IS_BETA" == "true" ]; then
                  CHECK_TAG="${version}-beta"
                else
                  CHECK_TAG="${version}"
                fi

                # Check if version exists in both registries
                DH_EXISTS=$(skopeo inspect "docker://${{ env.DOCKERHUB_REPO }}:${CHECK_TAG}" > /dev/null 2>&1 && echo "yes" || echo "no")
                GHCR_EXISTS=$(skopeo inspect "docker://${{ env.GHCR_REPO }}:${CHECK_TAG}" > /dev/null 2>&1 && echo "yes" || echo "no")

                if [ "$DH_EXISTS" == "yes" ] && [ "$GHCR_EXISTS" == "yes" ]; then
                  echo "::notice::Skipping version $version (tag: $CHECK_TAG) - already exists in both registries"
                  continue
                fi
              fi

              if [ -z "$filtered" ]; then
                filtered="$version"
              else
                filtered="$filtered,$version"
              fi
            done

            echo "$filtered"
          }

          # Check if base image update should trigger rebuild
          BASE_IMAGE_UPDATED="${{ steps.check-base-image.outputs.updated }}"
          UPDATE_BASE_IMAGE="${{ github.event.inputs.update_base_image || env.UPDATE_BASE_IMAGE_ENABLED }}"

          case "$ACTION" in
            "auto-check")
              DOCKERHUB_STATUS="${{ steps.check-existing.outputs.dockerhub_latest_status }}"
              GHCR_STATUS="${{ steps.check-existing.outputs.ghcr_latest_status }}"

              # Trigger build if: image missing OR force build OR (base image updated AND update enabled)
              if [ "$DOCKERHUB_STATUS" == "missing" ] || [ "$GHCR_STATUS" == "missing" ] || [ "$FORCE_BUILD" == "true" ] || \
                 ([ "$BASE_IMAGE_UPDATED" == "true" ] && [ "$UPDATE_BASE_IMAGE" == "true" ]); then
                echo "versions=$LATEST_VERSION" >> $GITHUB_OUTPUT
                echo "versions_json=[\"$LATEST_VERSION\"]" >> $GITHUB_OUTPUT
                echo "should_build=true" >> $GITHUB_OUTPUT
                if [ "$BASE_IMAGE_UPDATED" == "true" ] && [ "$UPDATE_BASE_IMAGE" == "true" ]; then
                  echo "Will rebuild latest version due to base image update: $LATEST_VERSION"
                else
                  echo "Will build latest version: $LATEST_VERSION"
                fi
              else
                echo "versions=" >> $GITHUB_OUTPUT
                echo "versions_json=[]" >> $GITHUB_OUTPUT
                echo "should_build=false" >> $GITHUB_OUTPUT
                echo "Latest version already exists in both registries (base image unchanged)"
              fi
              ;;

            "build-versions")
              VALID_VERSIONS="${{ steps.validate-versions.outputs.valid_versions }}"

              if [ -z "$VALID_VERSIONS" ]; then
                echo "::warning::No valid versions to build"
                echo "versions=" >> $GITHUB_OUTPUT
                echo "versions_json=[]" >> $GITHUB_OUTPUT
                echo "should_build=false" >> $GITHUB_OUTPUT
              else
                # Filter out existing versions if skip_existing is true
                FILTERED_VERSIONS=$(filter_existing_versions "$VALID_VERSIONS")

                if [ -z "$FILTERED_VERSIONS" ]; then
                  echo "::notice::All requested versions already exist in registries"
                  echo "versions=" >> $GITHUB_OUTPUT
                  echo "versions_json=[]" >> $GITHUB_OUTPUT
                  echo "should_build=false" >> $GITHUB_OUTPUT
                else
                  echo "versions=$FILTERED_VERSIONS" >> $GITHUB_OUTPUT
                  # Convert to JSON array
                  JSON_ARRAY=$(echo "$FILTERED_VERSIONS" | sed 's/,/","/g' | sed 's/^/["/' | sed 's/$/"]/')
                  echo "versions_json=$JSON_ARRAY" >> $GITHUB_OUTPUT
                  echo "should_build=true" >> $GITHUB_OUTPUT
                  echo "Will build versions: $FILTERED_VERSIONS"
                fi
              fi
              ;;

            "promote-image"|"sync-registries"|"mark-stable")
              echo "versions=" >> $GITHUB_OUTPUT
              echo "versions_json=[]" >> $GITHUB_OUTPUT
              echo "should_build=false" >> $GITHUB_OUTPUT
              ;;
          esac

      - name: Generate build matrix
        id: generate-matrix
        run: |
          VERSIONS='${{ steps.determine-versions.outputs.versions_json }}'
          BETA_VERSIONS='${{ steps.fetch-releases.outputs.beta_versions }}'
          
          # If no versions to build, output empty matrix
          if [ "$VERSIONS" == "[]" ] || [ -z "$VERSIONS" ]; then
            echo "matrix=[]" >> $GITHUB_OUTPUT
            echo "No versions to build, empty matrix"
            exit 0
          fi
          
          # Generate combined matrix: [{version, platform, platform_slug, is_beta}, ...]
          MATRIX=$(echo "$VERSIONS" | jq -c --argjson betas "$BETA_VERSIONS" '
            . as $versions |
            ["linux/amd64", "linux/arm64", "linux/arm/v7"] as $platforms |
            [
              $versions[] as $v |
              $platforms[] as $p |
              {
                version: $v,
                platform: $p,
                platform_slug: ($p | gsub("/"; "-")),
                is_beta: (if $betas[$v] == true then "true" else "false" end)
              }
            ]
          ')
          
          echo "matrix=$MATRIX" >> $GITHUB_OUTPUT
          echo "Generated build matrix with $(echo $MATRIX | jq length) entries"
          echo "$MATRIX" | jq .

      - name: Summary
        run: |
          echo "## Release Check Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Action | ${{ steps.set-action.outputs.action }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Latest Version | ${{ steps.fetch-releases.outputs.latest_version }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Versions to Build | ${{ steps.determine-versions.outputs.versions || 'None' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Should Build | ${{ steps.determine-versions.outputs.should_build }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Missing Versions | ${{ steps.validate-versions.outputs.missing_versions || 'None' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Eligible for Stable | ${{ steps.check-stable.outputs.should_mark_stable }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Base Image Selection | ${{ steps.resolve-base-image.outputs.selection }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Base Image Updated | ${{ steps.check-base-image.outputs.updated }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Platforms | ${{ steps.set-platforms.outputs.platforms }} |" >> $GITHUB_STEP_SUMMARY
          echo "| ZSTD Compression | Level ${{ steps.set-compression.outputs.level }} |" >> $GITHUB_STEP_SUMMARY

  # ===========================================================================
  # Job 2: Build Docker images per platform (Split Build Strategy)
  # ===========================================================================
  build-platform:
    name: Build ${{ matrix.version }} (${{ matrix.platform_slug }})
    needs: check-releases
    if: needs.check-releases.outputs.should_build == 'true' && needs.check-releases.outputs.build_matrix != ''
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    # Prevent building the same version+platform concurrently
    concurrency:
      group: build-${{ matrix.version }}-${{ matrix.platform_slug }}
      cancel-in-progress: false
    strategy:
      fail-fast: false
      max-parallel: 6
      matrix:
        include: ${{ fromJson(needs.check-releases.outputs.build_matrix) }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Free disk space
        run: |
          echo "Freeing up disk space..."
          sudo rm -rf /usr/share/dotnet /usr/local/lib/android /opt/ghc
          sudo apt-get clean
          df -h

      - name: Set up QEMU for cross-platform builds
        if: matrix.platform != 'linux/amd64'
        uses: docker/setup-qemu-action@v3
        with:
          platforms: ${{ matrix.platform }}

      - name: Set up Docker Buildx (ultra-optimized)
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            image=moby/buildkit:master
            network=host
          buildkitd-flags: --debug --allow-insecure-entitlement network.host
          # Ultra-optimized BuildKit configuration
          buildkitd-config-inline: |
            [worker.oci]
              max-parallelism = 4
              gc = true
              gckeepstorage = 20000000000
              [[worker.oci.gcpolicy]]
                keepBytes = 20000000000
                keepDuration = 604800
                filters = ["type==source.local", "type==exec.cachemount", "type==source.git.checkout"]
              [[worker.oci.gcpolicy]]
                all = true
                keepBytes = 50000000000
            [registry."docker.io"]
              mirrors = ["mirror.gcr.io"]

      - name: Login to registries
        uses: ./.github/actions/registry-login
        with:
          dockerhub_username: ${{ secrets.DOCKERHUB_USERNAME }}
          dockerhub_token: ${{ secrets.DOCKERHUB_TOKEN }}
          ghcr_actor: ${{ github.actor }}
          ghcr_token: ${{ secrets.GITHUB_TOKEN }}
          push_to_dockerhub: ${{ github.event.inputs.push_to_dockerhub || 'true' }}
          push_to_ghcr: ${{ github.event.inputs.push_to_ghcr || 'true' }}

      - name: Prepare build context
        id: prepare
        env:
          DEFAULT_IMAGE: ${{ env.DEFAULT_BASE_IMAGE }}
        run: |
          VERSION="${{ matrix.version }}"
          VERSION_UNDERSCORE="${VERSION//./_}"
          BASE_SELECTION="${{ needs.check-releases.outputs.base_image_selection }}"
          CUSTOM_BASE="${{ needs.check-releases.outputs.custom_base_image }}"

          # Resolve base image from selection key (avoids GitHub Actions secret masking)
          case "$BASE_SELECTION" in
            "custom")
              if [ -n "$CUSTOM_BASE" ]; then
                BASE_IMAGE="$CUSTOM_BASE"
              else
                BASE_IMAGE="$DEFAULT_IMAGE"
              fi
              ;;
            "trixie-slim-default-ffmpeg")
              BASE_IMAGE="mekayelanik/ispyagentdvr-base-image:ispyagentdvr-trixie-slim-default-ffmpeg"
              ;;
            "bookworm-slim-vlc-jellyfin-ffmpeg")
              BASE_IMAGE="mekayelanik/ispyagentdvr-base-image:ispyagentdvr-bookworm-slim-vlc-jellyfin-ffmpeg"
              ;;
            *)
              BASE_IMAGE="$DEFAULT_IMAGE"
              ;;
          esac

          # Final fallback
          if [ -z "$BASE_IMAGE" ]; then
            BASE_IMAGE="$DEFAULT_IMAGE"
          fi

          # Create build_data directory
          mkdir -p resources/build_data

          # Write required files
          echo "$BASE_IMAGE" > resources/build_data/base-image
          echo "$VERSION_UNDERSCORE" > resources/build_data/version
          echo "${{ env.BINARY_BASE_URL }}" > resources/build_data/binary_server_url
          # NOTE: Do NOT create 'publication' file - its existence skips setup in DockerfileModifier.sh

          # Create build timestamp (will be copied to /AgentDVR/build-timestamp in container)
          BUILD_TIME=$(TZ="${{ env.TZ }}" date +"%Y-%m-%d %H:%M:%S")
          echo "Image built on: $BUILD_TIME Bangladesh Standard Time | Version: $VERSION | Platform: ${{ matrix.platform }}" > resources/build-timestamp

          echo "=== Build Configuration ==="
          echo "Version: $VERSION"
          echo "Version (underscore): $VERSION_UNDERSCORE"
          echo "Platform: ${{ matrix.platform }}"
          echo "Base Image: $BASE_IMAGE"
          echo "Binary URL: ${{ env.BINARY_BASE_URL }}"

          # Output validated base image for subsequent steps
          echo "base_image=$BASE_IMAGE" >> $GITHUB_OUTPUT

          # Generate Dockerfile
          bash DockerfileModifier.sh

          echo ""
          echo "=== Generated Dockerfile ==="
          cat Dockerfile.ispyagentdvr-docker

      - name: Get base image digest
        id: base-digest
        run: |
          # Use the base image resolved in prepare step
          BASE_IMAGE="${{ steps.prepare.outputs.base_image }}"
          BASE_DIGEST=$(skopeo inspect "docker://${BASE_IMAGE}" 2>/dev/null | jq -r '.Digest' || echo "unknown")
          echo "digest=$BASE_DIGEST" >> $GITHUB_OUTPUT
          echo "Base image digest: $BASE_DIGEST"

      - name: Determine cache reference
        id: cache-ref
        run: |
          # Map platform to cache tag
          case "${{ matrix.platform }}" in
            "linux/amd64") CACHE_TAG="buildcache-amd64" ;;
            "linux/arm64") CACHE_TAG="buildcache-arm64" ;;
            "linux/arm/v7") CACHE_TAG="buildcache-armv7" ;;
            *) CACHE_TAG="buildcache-${{ matrix.platform_slug }}" ;;
          esac
          echo "cache_tag=$CACHE_TAG" >> $GITHUB_OUTPUT
          echo "Using cache reference: $CACHE_TAG"

      - name: Generate Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: |
            ${{ env.DOCKERHUB_REPO }}
            ${{ env.GHCR_REPO }}
          labels: |
            org.opencontainers.image.title=iSpy Agent DVR
            org.opencontainers.image.description=Agent DVR - Professional video surveillance software for Linux, Windows and macOS
            org.opencontainers.image.vendor=mekayelanik
            org.opencontainers.image.version=${{ matrix.version }}
            org.opencontainers.image.source=https://github.com/${{ github.repository }}
            org.opencontainers.image.documentation=https://www.ispyconnect.com/docs/agent/about
            org.opencontainers.image.base.name=${{ steps.prepare.outputs.base_image }}
            org.opencontainers.image.base.digest=${{ steps.base-digest.outputs.digest }}
            org.opencontainers.image.revision=${{ github.sha }}
            ispyagentdvr.release.beta=${{ matrix.is_beta }}

      - name: Build and push by digest
        id: build-push
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile.ispyagentdvr-docker
          platforms: ${{ matrix.platform }}
          labels: ${{ steps.meta.outputs.labels }}
          # Per-architecture cache configuration
          cache-from: |
            type=registry,ref=${{ env.GHCR_REPO }}:${{ steps.cache-ref.outputs.cache_tag }}
            type=gha,scope=build-${{ matrix.version }}-${{ matrix.platform_slug }}
          cache-to: |
            type=registry,ref=${{ env.GHCR_REPO }}:${{ steps.cache-ref.outputs.cache_tag }},mode=max,compression=zstd,compression-level=${{ needs.check-releases.outputs.compression_level }}
            type=gha,scope=build-${{ matrix.version }}-${{ matrix.platform_slug }},mode=max,compression=zstd,compression-level=${{ needs.check-releases.outputs.compression_level }}
          # Security attestations
          provenance: mode=max
          sbom: true
          # Build arguments
          build-args: |
            BASE_IMAGE=${{ steps.prepare.outputs.base_image }}
            AGENTDVR_VERSION=${{ matrix.version }}
            BUILDKIT_INLINE_CACHE=1
          # Push by digest - no tags, outputs digest for manifest creation
          outputs: type=image,name=${{ env.DOCKERHUB_REPO }},push-by-digest=true,name-canonical=true,push=true,oci-mediatypes=true,compression=zstd,compression-level=${{ needs.check-releases.outputs.compression_level }},force-compression=true
          # Allow network access during build
          allow: network.host
          # Use BuildKit features
          build-contexts: |
            resources=./resources

      - name: Export digest
        run: |
          mkdir -p /tmp/digests
          digest="${{ steps.build-push.outputs.digest }}"
          touch "/tmp/digests/${digest#sha256:}"
          echo "Exported digest: $digest"

      - name: Upload digest artifact
        uses: actions/upload-artifact@v6
        with:
          name: digest-${{ matrix.version }}-${{ matrix.platform_slug }}
          path: /tmp/digests/*
          if-no-files-found: error
          retention-days: 1

      - name: Platform build summary
        run: |
          echo "## ðŸ”§ Platform Build: ${{ matrix.version }} (${{ matrix.platform }})" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Version | ${{ matrix.version }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Platform | ${{ matrix.platform }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Digest | \`${{ steps.build-push.outputs.digest }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Image ID | ${{ steps.build-push.outputs.imageid }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Base Image | ${{ steps.prepare.outputs.base_image }} |" >> $GITHUB_STEP_SUMMARY
          echo "| ZSTD Compression | Level ${{ needs.check-releases.outputs.compression_level }} |" >> $GITHUB_STEP_SUMMARY

  # ===========================================================================
  # Job 2b: Merge platform manifests into multi-arch images
  # ===========================================================================
  merge-manifest:
    name: Merge Manifest ${{ matrix.version }}
    needs: [check-releases, build-platform]
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    strategy:
      fail-fast: false
      matrix:
        version: ${{ fromJson(needs.check-releases.outputs.versions_json) }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to registries
        uses: ./.github/actions/registry-login
        with:
          dockerhub_username: ${{ secrets.DOCKERHUB_USERNAME }}
          dockerhub_token: ${{ secrets.DOCKERHUB_TOKEN }}
          ghcr_actor: ${{ github.actor }}
          ghcr_token: ${{ secrets.GITHUB_TOKEN }}
          push_to_dockerhub: ${{ github.event.inputs.push_to_dockerhub || 'true' }}
          push_to_ghcr: ${{ github.event.inputs.push_to_ghcr || 'true' }}

      - name: Download all digests for version
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131 # v7
        with:
          path: /tmp/digests
          pattern: digest-${{ matrix.version }}-*
          merge-multiple: true

      - name: List downloaded digests
        run: |
          echo "Downloaded digests for ${{ matrix.version }}:"
          ls -la /tmp/digests/
          echo "Digest files:"
          for f in /tmp/digests/*; do
            echo "  - sha256:$(basename $f)"
          done

      - name: Determine image tags
        id: tags
        run: |
          VERSION="${{ matrix.version }}"
          LATEST_VERSION="${{ needs.check-releases.outputs.latest_version }}"
          BETA_VERSIONS='${{ needs.check-releases.outputs.beta_versions }}'
          TAG_AS_LATEST="${{ github.event.inputs.tag_as_latest }}"
          PUSH_DOCKERHUB="${{ github.event.inputs.push_to_dockerhub }}"
          PUSH_GHCR="${{ github.event.inputs.push_to_ghcr }}"

          # Check if current version is beta
          IS_BETA=$(echo "$BETA_VERSIONS" | jq -r --arg v "$VERSION" '.[$v] // false')
          echo "Version $VERSION is beta: $IS_BETA"

          # Generate date tag in Bangladesh time (UTC+6) - format: DDMMYYYY
          DATE_TAG=$(TZ=Asia/Dhaka date +"%d%m%Y")

          # Generate tags based on beta status
          if [ "$IS_BETA" == "true" ]; then
            VERSION_TAG="${VERSION}-beta"
            VERSION_DATE_TAG="${VERSION}-beta-${DATE_TAG}"
            ROLLING_TAG="beta"
          else
            VERSION_TAG="${VERSION}"
            VERSION_DATE_TAG="${VERSION}-${DATE_TAG}"
            ROLLING_TAG="latest"
          fi

          # Build tag lists for imagetools
          DOCKERHUB_TAGS=""
          GHCR_TAGS=""

          if [ "$PUSH_DOCKERHUB" != "false" ]; then
            DOCKERHUB_TAGS="-t ${{ env.DOCKERHUB_REPO }}:${VERSION_TAG}"
            DOCKERHUB_TAGS="$DOCKERHUB_TAGS -t ${{ env.DOCKERHUB_REPO }}:${VERSION_DATE_TAG}"
            if [ "$VERSION" == "$LATEST_VERSION" ] || [ "$TAG_AS_LATEST" == "true" ]; then
              DOCKERHUB_TAGS="$DOCKERHUB_TAGS -t ${{ env.DOCKERHUB_REPO }}:${ROLLING_TAG}"
            fi
          fi

          if [ "$PUSH_GHCR" != "false" ]; then
            GHCR_TAGS="-t ${{ env.GHCR_REPO }}:${VERSION_TAG}"
            GHCR_TAGS="$GHCR_TAGS -t ${{ env.GHCR_REPO }}:${VERSION_DATE_TAG}"
            if [ "$VERSION" == "$LATEST_VERSION" ] || [ "$TAG_AS_LATEST" == "true" ]; then
              GHCR_TAGS="$GHCR_TAGS -t ${{ env.GHCR_REPO }}:${ROLLING_TAG}"
            fi
          fi

          echo "dockerhub_tags=$DOCKERHUB_TAGS" >> $GITHUB_OUTPUT
          echo "ghcr_tags=$GHCR_TAGS" >> $GITHUB_OUTPUT
          echo "date_tag=$DATE_TAG" >> $GITHUB_OUTPUT
          echo "is_beta=$IS_BETA" >> $GITHUB_OUTPUT
          echo "version_tag=$VERSION_TAG" >> $GITHUB_OUTPUT
          echo "rolling_tag=$ROLLING_TAG" >> $GITHUB_OUTPUT

          echo "Docker Hub tags: $DOCKERHUB_TAGS"
          echo "GHCR tags: $GHCR_TAGS"

      - name: Create and push multi-arch manifest (Docker Hub)
        if: github.event.inputs.push_to_dockerhub != 'false'
        run: |
          # Build source images list from digests
          SOURCES=""
          for digest_file in /tmp/digests/*; do
            digest="sha256:$(basename $digest_file)"
            SOURCES="$SOURCES ${{ env.DOCKERHUB_REPO }}@${digest}"
          done

          echo "Creating multi-arch manifest for Docker Hub..."
          echo "Sources: $SOURCES"
          echo "Tags: ${{ steps.tags.outputs.dockerhub_tags }}"

          # Retry logic for transient network failures
          for attempt in 1 2 3; do
            echo "Attempt $attempt of 3..."
            if docker buildx imagetools create \
              ${{ steps.tags.outputs.dockerhub_tags }} \
              $SOURCES; then
              echo "Docker Hub manifest created successfully"
              break
            fi
            if [ $attempt -lt 3 ]; then
              echo "Retrying in 10 seconds..."
              sleep 10
            else
              echo "Failed after 3 attempts"
              exit 1
            fi
          done

      - name: Create and push multi-arch manifest (GHCR)
        if: github.event.inputs.push_to_ghcr != 'false'
        run: |
          # Build source images list from digests
          SOURCES=""
          for digest_file in /tmp/digests/*; do
            digest="sha256:$(basename $digest_file)"
            SOURCES="$SOURCES ${{ env.DOCKERHUB_REPO }}@${digest}"
          done

          echo "Creating multi-arch manifest for GHCR..."
          echo "Sources: $SOURCES"
          echo "Tags: ${{ steps.tags.outputs.ghcr_tags }}"

          # Retry logic for transient network failures (GHCR can be flaky)
          for attempt in 1 2 3; do
            echo "Attempt $attempt of 3..."
            if docker buildx imagetools create \
              ${{ steps.tags.outputs.ghcr_tags }} \
              $SOURCES; then
              echo "GHCR manifest created successfully"
              break
            fi
            if [ $attempt -lt 3 ]; then
              echo "Retrying in 15 seconds..."
              sleep 15
            else
              echo "Failed after 3 attempts"
              exit 1
            fi
          done

      - name: Run Trivy vulnerability scanner
        if: github.event.inputs.run_security_scan != 'false'
        uses: aquasecurity/trivy-action@b6643a29fecd7f34b3597bc6acb0a98b03d33ff8 # 0.33.1
        with:
          image-ref: '${{ env.DOCKERHUB_REPO }}:${{ steps.tags.outputs.version_tag }}'
          format: 'sarif'
          output: 'trivy-results-${{ matrix.version }}.sarif'
          severity: 'CRITICAL,HIGH'
          timeout: '10m'
        continue-on-error: true

      - name: Upload Trivy scan results
        if: github.event.inputs.run_security_scan != 'false'
        uses: github/codeql-action/upload-sarif@b20883b0cd1f46c72ae0ba6d1090936928f9fa30 # v4
        with:
          sarif_file: 'trivy-results-${{ matrix.version }}.sarif'
          category: 'trivy-${{ matrix.version }}'
        continue-on-error: true

      - name: Build summary
        run: |
          BETA_STATUS="${{ steps.tags.outputs.is_beta }}"
          if [ "$BETA_STATUS" == "true" ]; then
            echo "## ðŸ§ª Build Complete: ${{ matrix.version }} (BETA)" >> $GITHUB_STEP_SUMMARY
          else
            echo "## âœ… Build Complete: ${{ matrix.version }}" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Version | ${{ matrix.version }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Release Type | ${{ steps.tags.outputs.is_beta == 'true' && 'ðŸ§ª Beta' || 'ðŸ“¦ Stable' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Platforms | ${{ needs.check-releases.outputs.platforms }} |" >> $GITHUB_STEP_SUMMARY
          echo "| ZSTD Compression | Level ${{ needs.check-releases.outputs.compression_level }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Tags Applied" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "${{ steps.tags.outputs.dockerhub_tags }} ${{ steps.tags.outputs.ghcr_tags }}" | tr ' ' '\n' | grep -v '^-t$' | grep -v '^$' >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Platform Digests" >> $GITHUB_STEP_SUMMARY
          for f in /tmp/digests/*; do
            echo "- \`sha256:$(basename $f)\`" >> $GITHUB_STEP_SUMMARY
          done

      - name: Upload build artifacts
        uses: actions/upload-artifact@v6
        with:
          name: build-info-${{ matrix.version }}
          path: |
            trivy-results-${{ matrix.version }}.sarif
          retention-days: 30
          if-no-files-found: ignore

  # ===========================================================================
  # Job 3: Sync registries
  # ===========================================================================
  sync-registries:
    name: Sync Registries
    needs: [check-releases, merge-manifest]
    if: |
      always() &&
      (needs.check-releases.outputs.action_type == 'sync-registries' ||
       (needs.check-releases.outputs.action_type == 'auto-check' && needs.merge-manifest.result == 'success'))
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Install skopeo
        run: sudo apt-get update && sudo apt-get install -y skopeo

      - name: Login to registries
        uses: ./.github/actions/registry-login
        with:
          dockerhub_username: ${{ secrets.DOCKERHUB_USERNAME }}
          dockerhub_token: ${{ secrets.DOCKERHUB_TOKEN }}
          ghcr_actor: ${{ github.actor }}
          ghcr_token: ${{ secrets.GITHUB_TOKEN }}

      - name: Sync images between registries
        uses: ./.github/actions/registry-sync
        with:
          dockerhub_repo: ${{ env.DOCKERHUB_REPO }}
          ghcr_repo: ${{ env.GHCR_REPO }}
          tags: ${{ needs.check-releases.outputs.latest_version }},latest,stable,${{ needs.check-releases.outputs.versions_to_build }}

  # ===========================================================================
  # Job 4: Promote image to latest or stable
  # ===========================================================================
  promote-image:
    name: Promote Image
    needs: check-releases
    if: needs.check-releases.outputs.action_type == 'promote-image'
    runs-on: ubuntu-latest

    steps:
      - name: Validate inputs
        run: |
          if [ -z "${{ github.event.inputs.promote_version }}" ]; then
            echo "::error::Source version is required for image promotion"
            exit 1
          fi

      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Install skopeo
        run: sudo apt-get update && sudo apt-get install -y skopeo

      - name: Login to registries
        uses: ./.github/actions/registry-login
        with:
          dockerhub_username: ${{ secrets.DOCKERHUB_USERNAME }}
          dockerhub_token: ${{ secrets.DOCKERHUB_TOKEN }}
          ghcr_actor: ${{ github.actor }}
          ghcr_token: ${{ secrets.GITHUB_TOKEN }}

      - name: Promote image
        run: |
          SOURCE="${{ github.event.inputs.promote_version }}"
          TARGET="${{ github.event.inputs.promote_tag }}"

          echo "Promoting version $SOURCE to $TARGET..."

          # Check source exists
          if ! skopeo inspect "docker://${{ env.DOCKERHUB_REPO }}:${SOURCE}" > /dev/null 2>&1; then
            echo "::error::Source version $SOURCE not found in Docker Hub"
            exit 1
          fi

          # Promote on Docker Hub
          echo "Promoting on Docker Hub..."
          skopeo copy --all \
            "docker://${{ env.DOCKERHUB_REPO }}:${SOURCE}" \
            "docker://${{ env.DOCKERHUB_REPO }}:${TARGET}"

          # Promote on GHCR
          echo "Promoting on GHCR..."
          skopeo copy --all \
            "docker://${{ env.GHCR_REPO }}:${SOURCE}" \
            "docker://${{ env.GHCR_REPO }}:${TARGET}"

          echo "Successfully promoted $SOURCE to $TARGET on both registries"

          echo "## Image Promotion" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Source | Target | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|--------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| $SOURCE | $TARGET | Success |" >> $GITHUB_STEP_SUMMARY

  # ===========================================================================
  # Job 5: Mark stable (5-day rule)
  # ===========================================================================
  mark-stable:
    name: Mark Stable
    needs: [check-releases, merge-manifest, sync-registries]
    if: |
      always() &&
      (needs.check-releases.outputs.action_type == 'mark-stable' ||
       (needs.check-releases.outputs.action_type == 'auto-check' &&
        needs.check-releases.outputs.should_mark_stable == 'true'))
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Install skopeo
        run: sudo apt-get update && sudo apt-get install -y skopeo

      - name: Login to registries
        uses: ./.github/actions/registry-login
        with:
          dockerhub_username: ${{ secrets.DOCKERHUB_USERNAME }}
          dockerhub_token: ${{ secrets.DOCKERHUB_TOKEN }}
          ghcr_actor: ${{ github.actor }}
          ghcr_token: ${{ secrets.GITHUB_TOKEN }}

      - name: Check and promote to stable
        run: |
          STABLE_VERSION="${{ needs.check-releases.outputs.stable_version }}"

          if [ -z "$STABLE_VERSION" ]; then
            echo "No version eligible for stable promotion"
            exit 0
          fi

          echo "Checking if stable tag needs update..."

          # Get digests
          CURRENT_STABLE=$(skopeo inspect "docker://${{ env.DOCKERHUB_REPO }}:stable" 2>/dev/null | jq -r '.Digest' || echo "none")
          VERSION_DIGEST=$(skopeo inspect "docker://${{ env.DOCKERHUB_REPO }}:${STABLE_VERSION}" 2>/dev/null | jq -r '.Digest' || echo "none")

          echo "Current stable digest: $CURRENT_STABLE"
          echo "Version $STABLE_VERSION digest: $VERSION_DIGEST"

          if [ "$CURRENT_STABLE" == "$VERSION_DIGEST" ] && [ "$CURRENT_STABLE" != "none" ]; then
            echo "Stable tag already points to version $STABLE_VERSION"
            exit 0
          fi

          echo "Marking version $STABLE_VERSION as stable..."

          # Promote on Docker Hub
          skopeo copy --all \
            "docker://${{ env.DOCKERHUB_REPO }}:${STABLE_VERSION}" \
            "docker://${{ env.DOCKERHUB_REPO }}:stable"

          # Promote on GHCR
          skopeo copy --all \
            "docker://${{ env.GHCR_REPO }}:${STABLE_VERSION}" \
            "docker://${{ env.GHCR_REPO }}:stable"

          echo "Successfully marked $STABLE_VERSION as stable"

          echo "## Stable Promotion" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Version **$STABLE_VERSION** has been marked as **stable**" >> $GITHUB_STEP_SUMMARY

  # ===========================================================================
  # Job 6: Update repository metadata
  # ===========================================================================
  update-metadata:
    name: Update Metadata
    needs: [check-releases, merge-manifest, sync-registries, mark-stable]
    if: always() && needs.merge-manifest.result == 'success'
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Update build metadata
        run: |
          LATEST_VERSION="${{ needs.check-releases.outputs.latest_version }}"
          CURRENT_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

          # Update tag file
          echo "$LATEST_VERSION" > resources/tag

          # Update build timestamp
          echo "Last successful build: $CURRENT_TIME" > resources/build-timestamp

          # Update version file (underscore format)
          VERSION_UNDERSCORE="${LATEST_VERSION//./_}"
          mkdir -p resources/build_data
          echo "$VERSION_UNDERSCORE" > resources/build_data/version

          # Update .agentdvr-version (consolidated from check-agentdvr-version workflow)
          echo "$LATEST_VERSION" > .agentdvr-version

          echo "Updated metadata files"

      - name: Commit changes
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add resources/tag resources/build-timestamp resources/build_data/version .agentdvr-version 2>/dev/null || true

          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "chore: update build metadata

            Version: ${{ needs.check-releases.outputs.latest_version }}
            Built: $(date -u +"%Y-%m-%dT%H:%M:%SZ")

            [skip ci]"
            git push
          fi
